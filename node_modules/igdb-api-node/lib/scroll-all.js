"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _utilities = require("./utilities");

var promiseWhile = function promiseWhile(condition, execute) {
  return new Promise(function (resolve, reject) {
    var iterate = function iterate() {
      if (condition()) {
        return execute().then(iterate).catch(reject);
      }

      return resolve();
    };

    return iterate();
  });
};

var _default = function _default(url, options, apiService, request) {
  return new Promise(function (accept, reject) {
    if (!url) {
      reject(new Error('No url provided for scrollAll'));
    }

    var newUrl = (0, _utilities.addScrollParameter)(url);
    options = Object.assign({}, {
      interval: 500
    }, options);
    var results = [],
        xNextPage,
        xCount,
        maxPages = 2,
        currentPage = 1,
        first = true;
    promiseWhile(function () {
      if (!first) {
        if (results.length >= xCount) {
          return false;
        }

        if (maxPages <= currentPage) {
          return false;
        }

        currentPage += 1;
      }

      return true;
    }, function () {
      return new Promise(function (accept2, reject2) {
        request("".concat(apiService.url).concat(xNextPage || newUrl), apiService).then(function (response) {
          if (first) {
            first = false;
            xNextPage = response.headers['x-next-page'];
            xCount = parseInt(response.headers['x-count'], 10);
            maxPages = Math.round(xCount / response.body.length);

            if (options.pageLimit && options.pageLimit < maxPages) {
              maxPages = options.pageLimit;
            }
          }

          if (response.body && !response.body.length) {
            first = false;
            maxPages = currentPage;
            accept2();
            return;
          }

          results = results.concat(response.body);
          setTimeout(function () {
            return accept2();
          }, options.interval);
        }).catch(reject2);
      });
    }).then(function () {
      accept(results);
    }).catch(reject);
  });
};

exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2pzL3Njcm9sbC1hbGwuanMiXSwibmFtZXMiOlsicHJvbWlzZVdoaWxlIiwiY29uZGl0aW9uIiwiZXhlY3V0ZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiaXRlcmF0ZSIsInRoZW4iLCJjYXRjaCIsInVybCIsIm9wdGlvbnMiLCJhcGlTZXJ2aWNlIiwicmVxdWVzdCIsImFjY2VwdCIsIkVycm9yIiwibmV3VXJsIiwiT2JqZWN0IiwiYXNzaWduIiwiaW50ZXJ2YWwiLCJyZXN1bHRzIiwieE5leHRQYWdlIiwieENvdW50IiwibWF4UGFnZXMiLCJjdXJyZW50UGFnZSIsImZpcnN0IiwibGVuZ3RoIiwiYWNjZXB0MiIsInJlamVjdDIiLCJyZXNwb25zZSIsImhlYWRlcnMiLCJwYXJzZUludCIsIk1hdGgiLCJyb3VuZCIsImJvZHkiLCJwYWdlTGltaXQiLCJjb25jYXQiLCJzZXRUaW1lb3V0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBRUEsSUFBTUEsZUFBZSxTQUFmQSxZQUFlLENBQUNDLFNBQUQsRUFBWUMsT0FBWjtBQUFBLFNBQXdCLElBQUlDLE9BQUosQ0FBWSxVQUFDQyxPQUFELEVBQVVDLE1BQVYsRUFBcUI7QUFDMUUsUUFBTUMsVUFBVSxTQUFWQSxPQUFVLEdBQU07QUFDbEIsVUFBSUwsV0FBSixFQUFpQjtBQUNiLGVBQU9DLFVBQ0ZLLElBREUsQ0FDR0QsT0FESCxFQUVGRSxLQUZFLENBRUlILE1BRkosQ0FBUDtBQUdIOztBQUNELGFBQU9ELFNBQVA7QUFDSCxLQVBEOztBQVNBLFdBQU9FLFNBQVA7QUFDSCxHQVg0QyxDQUF4QjtBQUFBLENBQXJCOztlQXFCZSxrQkFBQ0csR0FBRCxFQUFNQyxPQUFOLEVBQWVDLFVBQWYsRUFBMkJDLE9BQTNCO0FBQUEsU0FBdUMsSUFBSVQsT0FBSixDQUFZLFVBQUNVLE1BQUQsRUFBU1IsTUFBVCxFQUFvQjtBQUNsRixRQUFJLENBQUNJLEdBQUwsRUFBVTtBQUNOSixhQUFPLElBQUlTLEtBQUosQ0FBVSwrQkFBVixDQUFQO0FBQ0g7O0FBR0QsUUFBTUMsU0FBUyxtQ0FBbUJOLEdBQW5CLENBQWY7QUFFQUMsY0FBVU0sT0FBT0MsTUFBUCxDQUFjLEVBQWQsRUFBa0I7QUFDeEJDLGdCQUFVO0FBRGMsS0FBbEIsRUFFUFIsT0FGTyxDQUFWO0FBSUEsUUFBSVMsVUFBVSxFQUFkO0FBQUEsUUFDSUMsU0FESjtBQUFBLFFBRUlDLE1BRko7QUFBQSxRQUdJQyxXQUFXLENBSGY7QUFBQSxRQUlJQyxjQUFjLENBSmxCO0FBQUEsUUFLSUMsUUFBUSxJQUxaO0FBT0F4QixpQkFDSSxZQUFNO0FBQ0YsVUFBSSxDQUFDd0IsS0FBTCxFQUFZO0FBRVIsWUFBSUwsUUFBUU0sTUFBUixJQUFrQkosTUFBdEIsRUFBOEI7QUFDMUIsaUJBQU8sS0FBUDtBQUNIOztBQUdELFlBQUlDLFlBQVlDLFdBQWhCLEVBQTZCO0FBQ3pCLGlCQUFPLEtBQVA7QUFDSDs7QUFFREEsdUJBQWUsQ0FBZjtBQUNIOztBQUNELGFBQU8sSUFBUDtBQUNILEtBaEJMLEVBaUJJO0FBQUEsYUFBTSxJQUFJcEIsT0FBSixDQUFZLFVBQUN1QixPQUFELEVBQVVDLE9BQVYsRUFBc0I7QUFDcENmLDBCQUFXRCxXQUFXRixHQUF0QixTQUE0QlcsYUFBYUwsTUFBekMsR0FBbURKLFVBQW5ELEVBQ0tKLElBREwsQ0FDVSxvQkFBWTtBQUNkLGNBQUlpQixLQUFKLEVBQVc7QUFDUEEsb0JBQVEsS0FBUjtBQUNBSix3QkFBWVEsU0FBU0MsT0FBVCxDQUFpQixhQUFqQixDQUFaO0FBQ0FSLHFCQUFTUyxTQUFTRixTQUFTQyxPQUFULENBQWlCLFNBQWpCLENBQVQsRUFBc0MsRUFBdEMsQ0FBVDtBQUNBUCx1QkFBV1MsS0FBS0MsS0FBTCxDQUFXWCxTQUFTTyxTQUFTSyxJQUFULENBQWNSLE1BQWxDLENBQVg7O0FBR0EsZ0JBQUlmLFFBQVF3QixTQUFSLElBQXFCeEIsUUFBUXdCLFNBQVIsR0FBb0JaLFFBQTdDLEVBQXVEO0FBQ25EQSx5QkFBV1osUUFBUXdCLFNBQW5CO0FBQ0g7QUFDSjs7QUFHRCxjQUFJTixTQUFTSyxJQUFULElBQWlCLENBQUNMLFNBQVNLLElBQVQsQ0FBY1IsTUFBcEMsRUFBNEM7QUFDeENELG9CQUFRLEtBQVI7QUFDQUYsdUJBQVdDLFdBQVg7QUFDQUc7QUFDQTtBQUNIOztBQUVEUCxvQkFBVUEsUUFBUWdCLE1BQVIsQ0FBZVAsU0FBU0ssSUFBeEIsQ0FBVjtBQUNBRyxxQkFBVztBQUFBLG1CQUFNVixTQUFOO0FBQUEsV0FBWCxFQUE0QmhCLFFBQVFRLFFBQXBDO0FBQ0gsU0F4QkwsRUF3Qk9WLEtBeEJQLENBd0JhbUIsT0F4QmI7QUF5QkgsT0ExQkssQ0FBTjtBQUFBLEtBakJKLEVBNENFcEIsSUE1Q0YsQ0E0Q08sWUFBTTtBQUNUTSxhQUFPTSxPQUFQO0FBQ0gsS0E5Q0QsRUE4Q0dYLEtBOUNILENBOENTSCxNQTlDVDtBQStDSCxHQWxFcUQsQ0FBdkM7QUFBQSxDIiwiZmlsZSI6InNjcm9sbC1hbGwuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2FkZFNjcm9sbFBhcmFtZXRlcn0gZnJvbSAnLi91dGlsaXRpZXMnO1xuXG5jb25zdCBwcm9taXNlV2hpbGUgPSAoY29uZGl0aW9uLCBleGVjdXRlKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgaXRlcmF0ZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbigpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhlY3V0ZSgpXG4gICAgICAgICAgICAgICAgLnRoZW4oaXRlcmF0ZSlcbiAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gaXRlcmF0ZSgpO1xufSk7XG5cbi8qKlxuICogUmV0cmlldmVzIGFsbCBwYWdlcyBvciBhIGxpbWl0ZWQgc2V0IGFuZCByZXR1cm5zIGEgc2luZ2xlIGNvbmNhdGluYXRlZCBvYmplY3QuXG4gKiBAYXJnIHtTdHJpbmd9IHVybCBBIHF1ZXJ5IHVybFxuICogQGFyZyB7T2JqZWN0fSBvcHRpb25zIGEgc2VsZWN0aW9uIG9mIG9wdGlvbnMuXG4gKiBAYXJnIHtPYmplY3R9IGFwaVNlcnZpY2UgVGhlIEFQSSBzZXJ2aWNlIG9iamVjdCBjb250YWluaW5nIGVuZHBvaW50IGRldGFpbHMgYW5kIGtleVxuICogQGFyZyB7RnVuY3Rpb259IHJlcXVlc3QgVGhlIHBlcmZvcm0tcmVxdWVzdCBmdW5jdGlvblxuICogQHJldHVybnMge09iamVjdH0gQ29uY2F0aW5hdGVkIHJlc3VsdHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgKHVybCwgb3B0aW9ucywgYXBpU2VydmljZSwgcmVxdWVzdCkgPT4gbmV3IFByb21pc2UoKGFjY2VwdCwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTm8gdXJsIHByb3ZpZGVkIGZvciBzY3JvbGxBbGwnKSk7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHVybCBoYXMgc2Nyb2xsPTFcbiAgICBjb25zdCBuZXdVcmwgPSBhZGRTY3JvbGxQYXJhbWV0ZXIodXJsKTtcblxuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgICAgIGludGVydmFsOiA1MDBcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIGxldCByZXN1bHRzID0gW10sXG4gICAgICAgIHhOZXh0UGFnZSxcbiAgICAgICAgeENvdW50LFxuICAgICAgICBtYXhQYWdlcyA9IDIsXG4gICAgICAgIGN1cnJlbnRQYWdlID0gMSxcbiAgICAgICAgZmlyc3QgPSB0cnVlO1xuXG4gICAgcHJvbWlzZVdoaWxlKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgb25seSBvbmUgcGFnZSBvZiByZXN1bHRzLlxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzLmxlbmd0aCA+PSB4Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIGFsbCBwYWdlcyBoYXZlIGJlZW4gcmV0cmlldmVkXG4gICAgICAgICAgICAgICAgaWYgKG1heFBhZ2VzIDw9IGN1cnJlbnRQYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdXJyZW50UGFnZSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgICgpID0+IG5ldyBQcm9taXNlKChhY2NlcHQyLCByZWplY3QyKSA9PiB7XG4gICAgICAgICAgICByZXF1ZXN0KGAke2FwaVNlcnZpY2UudXJsfSR7eE5leHRQYWdlIHx8IG5ld1VybH1gLCBhcGlTZXJ2aWNlKVxuICAgICAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgeE5leHRQYWdlID0gcmVzcG9uc2UuaGVhZGVyc1sneC1uZXh0LXBhZ2UnXTsgLy8gTm93IG9ubHkgcXVlcnkgdGhlIGN1cnNvciB1cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICB4Q291bnQgPSBwYXJzZUludChyZXNwb25zZS5oZWFkZXJzWyd4LWNvdW50J10sIDEwKTsgLy8gU2V0IHRoZSB0b3RhbCByZXN1bHRzXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhQYWdlcyA9IE1hdGgucm91bmQoeENvdW50IC8gcmVzcG9uc2UuYm9keS5sZW5ndGgpOyAvLyBDb252ZXJ0IHRvdGFsIHJlc3VsdHMgdG8gdG90YWwgcGFnZXNcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgd2FudHMgb25seSBhIGxpbWl0ZWQgbnVtYmVyIG9mIHBhZ2VzLCBvdmVycmlkZSB0aGUgbWF4IHBhZ2VzLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucGFnZUxpbWl0ICYmIG9wdGlvbnMucGFnZUxpbWl0IDwgbWF4UGFnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhQYWdlcyA9IG9wdGlvbnMucGFnZUxpbWl0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBvbmx5IG9uZSBwYWdlIG9mIHJlc3VsdHMgb3Igc29tZSBvdGhlciBlcnJvclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuYm9keSAmJiAhcmVzcG9uc2UuYm9keS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhQYWdlcyA9IGN1cnJlbnRQYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXB0MigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KHJlc3BvbnNlLmJvZHkpO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGFjY2VwdDIoKSwgb3B0aW9ucy5pbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0Mik7XG4gICAgICAgIH0pLFxuICAgICkudGhlbigoKSA9PiB7XG4gICAgICAgIGFjY2VwdChyZXN1bHRzKTtcbiAgICB9KS5jYXRjaChyZWplY3QpO1xufSk7XG4iXX0=